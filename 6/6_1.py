# Запрограммировать, оформив в виде функции, расчет свертки y_i
# последовательности { x_i} с импульсной характеристикой {h_i } .
# На входе подпрограммы: массив данных {x_i , его длина, массив, содержащий
# значения {h_i }, количество элементов в этом массиве, момент времени (номер отсчета
# i) для которого считается свертка.
# На выходе подпрограммы: значение свертки i y в данный момент времени.
def convolution_at_time(x, x_length, h, h_length, i):
    """
    Рассчитывает значение свертки y[i] для заданных последовательностей x и h.

    :param x: массив данных {x_i}
    :param x_length: длина массива x
    :param h: массив, содержащий значения {h_i}
    :param h_length: количество элементов в массиве h
    :param i: момент времени (номер отсчета) для которого считается свертка
    :return: значение свертки y[i] в данный момент времени
    """
    # Проверка границ
    if i < 0 or i >= x_length + h_length - 1:
        raise ValueError("Индекс i выходит за пределы допустимого диапазона.")

    y_i = 0.0  # Инициализация результата свертки

    # Проходим по всем элементам импульсной характеристики
    for j in range(h_length):
        # Индекс в последовательности x
        x_index = i - j
        
        # Проверяем, находится ли индекс в пределах массива x
        if 0 <= x_index < x_length:
            y_i += x[x_index] * h[j]

    return y_i

# Пример использования функции
x = [1, 2, 3, 4, 5]  # Входная последовательность
h = [0.2, 0.5, 0.3]  # Импульсная характеристика

# Длина последовательностей
x_length = len(x)
h_length = len(h)

# Момент времени для расчета свертки
i = 3

# Расчет свертки
result = convolution_at_time(x, x_length, h, h_length, i)
print(f"Значение свертки y[{i}] = {result}")
